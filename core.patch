Index: SConscript
===================================================================
--- SConscript	(revision 13180)
+++ SConscript	(working copy)
@@ -36,6 +36,10 @@
 if env['CXX'].endswith('cl') or (env['CXX'] == '$CC' and env['CC'].endswith('cl')):
 	srcs['pcre'] = ('pcre/pcre.cxx', Glob('pcre/*.c'))
 
+svs_src, svs_inc = SConscript('SVS/SConscript')
+srcs['svs'] = (svs_src, svs_src)
+kernel_env.Append(CPPPATH = svs_inc)
+
 if GetOption('static'):
 	kernel_env.Append(CPPFLAGS=static_macro)
 	soarlib = kernel_env.Library('Soar', [srcs[c][scu] for c in srcs])
Index: ClientSML/src/sml_ClientKernel.h
===================================================================
--- ClientSML/src/sml_ClientKernel.h	(revision 13180)
+++ ClientSML/src/sml_ClientKernel.h	(working copy)
@@ -960,6 +960,8 @@
 	*************************************************************/
 	static Kernel* CreateEmbeddedConnection(bool clientThread, bool optimized, int portToListenOn) ;
 
+	void        SendSVSInput(const char* agentName, const std::string &txt);
+	std::string GetSVSOutput(const char* agentName);
 };
 
 }//closes namespace
Index: ClientSML/src/sml_ClientAgent.cpp
===================================================================
--- ClientSML/src/sml_ClientAgent.cpp	(revision 13180)
+++ ClientSML/src/sml_ClientAgent.cpp	(working copy)
@@ -1388,3 +1388,11 @@
 	}
 	return pClientIdentifier;
 }
+
+void Agent::SendSVSInput(const std::string &txt) {
+	GetKernel()->SendSVSInput(GetAgentName(), txt);
+}
+
+std::string Agent::GetSVSOutput() {
+	return GetKernel()->GetSVSOutput(GetAgentName());
+}
Index: ClientSML/src/sml_ClientAgent.h
===================================================================
--- ClientSML/src/sml_ClientAgent.h	(revision 13180)
+++ ClientSML/src/sml_ClientAgent.h	(working copy)
@@ -790,6 +790,9 @@
 	*************************************************************/
 	bool ExecuteCommandLineXML(char const* pCommandLine, ClientAnalyzedXML* pResponse) ;
 
+	void        SendSVSInput(const std::string &txt);
+	std::string GetSVSOutput();
+	
 	/*************************************************************
 	* @brief Get last command line result
 	*
Index: ClientSML/src/sml_ClientKernel.cpp
===================================================================
--- ClientSML/src/sml_ClientKernel.cpp	(revision 13180)
+++ ClientSML/src/sml_ClientKernel.cpp	(working copy)
@@ -2354,3 +2354,18 @@
 
 	return resultString;
 }
+
+void Kernel::SendSVSInput(const char* agentName, const std::string &txt) {
+	AnalyzeXML response;
+	GetConnection()->SendAgentCommand(&response, sml_Names::kCommand_SVSInput, agentName, sml_Names::kParamLine, txt.c_str() );
+}
+
+std::string Kernel::GetSVSOutput(const char* agentName) {
+	AnalyzeXML response;
+	if (GetConnection()->SendAgentCommand(&response, sml_Names::kCommand_SVSOutput, agentName, sml_Names::kParamLine, NULL))
+	{
+		return response.GetResultString();
+	} else {
+		return "";
+	}
+}
Index: KernelSML/src/sml_KernelSML.h
===================================================================
--- KernelSML/src/sml_KernelSML.h	(revision 13180)
+++ KernelSML/src/sml_KernelSML.h	(working copy)
@@ -463,6 +463,10 @@
 	// Note: Register and unregister are both sent to this one handler
 	bool HandleRegisterForEvent(AgentSML* pAgentSML, char const* pCommandName, Connection* pConnection, AnalyzeXML* pIncoming, soarxml::ElementXML* pResponse) ;
 
+	bool HandleSVSInput(AgentSML* pAgentSML, char const* pCommandName, Connection* pConnection, AnalyzeXML* pIncoming, soarxml::ElementXML* pResponse) ;
+
+	bool HandleSVSOutput(AgentSML* pAgentSML, char const* pCommandName, Connection* pConnection, AnalyzeXML* pIncoming, soarxml::ElementXML* pResponse) ;
+
 };
 
 }
Index: KernelSML/src/sml_KernelSMLHandlers.cpp
===================================================================
--- KernelSML/src/sml_KernelSMLHandlers.cpp	(revision 13180)
+++ KernelSML/src/sml_KernelSMLHandlers.cpp	(working copy)
@@ -34,6 +34,7 @@
 #include <stdlib.h>
 #include <assert.h>
 #include <algorithm>
+#include <sstream>
 #include "xml.h"
 
 using namespace sml ;
@@ -68,6 +69,7 @@
 	m_CommandMap[sml_Names::kCommand_ConvertIdentifier] = &sml::KernelSML::HandleConvertIdentifier;
 	m_CommandMap[sml_Names::kCommand_GetListenerPort]	= &sml::KernelSML::HandleGetListenerPort;
 	m_CommandMap[sml_Names::kCommand_GetLibraryLocation]= &sml::KernelSML::HandleGetLibraryLocation;
+	m_CommandMap[sml_Names::kCommand_SVSInput]			= &sml::KernelSML::HandleSVSInput;
 }
 
 /*************************************************************
@@ -934,3 +936,20 @@
 	return this->ReturnResult(pConnection, pResponse, this->GetLibraryLocation() ) ;
 }
 
+bool KernelSML::HandleSVSInput(AgentSML* pAgentSML, char const* pCommandName, Connection* pConnection, AnalyzeXML* pIncoming, soarxml::ElementXML* pResponse)
+{
+	// Get the parameters
+	char const* pLine = pIncoming->GetArgString(sml_Names::kParamLine) ;
+	if (!pLine)
+	{
+		return InvalidArg(pConnection, pResponse, pCommandName, "Command line missing") ;
+	}
+	pAgentSML->GetSoarAgent()->svs_instance->set_input(pLine);
+	return true;
+}
+
+bool KernelSML::HandleSVSOutput(AgentSML* pAgentSML, char const* pCommandName, Connection* pConnection, AnalyzeXML* pIncoming, soarxml::ElementXML* pResponse)
+{
+	std::string s = pAgentSML->GetSoarAgent()->svs_instance->get_output();
+	return this->ReturnResult(pConnection, pResponse, s.c_str()) ;
+}
Index: KernelSML/src/KernelHeaders.h
===================================================================
--- KernelSML/src/KernelHeaders.h	(revision 13180)
+++ KernelSML/src/KernelHeaders.h	(working copy)
@@ -29,3 +29,4 @@
 #include "symtab.h"
 #include "io_soar.h"
 #include "wmem.h"
+#include "svs.h"
Index: SoarKernel/src/agent.cpp
===================================================================
--- SoarKernel/src/agent.cpp	(revision 13180)
+++ SoarKernel/src/agent.cpp	(working copy)
@@ -52,6 +52,7 @@
 #include "wma.h"
 #include "episodic_memory.h"
 #include "semantic_memory.h"
+#include "svs.h"
 
 
 /* ================================================================== */
@@ -131,6 +132,8 @@
 
   reset_statistics (thisAgent);
 
+  thisAgent->svs_instance = new svs(thisAgent);
+
   /* RDF: For gSKI */
   init_agent_memory(thisAgent);
   /* END */
@@ -491,6 +494,8 @@
 
   delete delete_agent->smem_db;
 
+  delete delete_agent->svs_instance;
+
   // cleanup statistics db
   stats_close( delete_agent );
   delete delete_agent->stats_db;
Index: SoarKernel/src/init_soar.cpp
===================================================================
--- SoarKernel/src/init_soar.cpp	(revision 13180)
+++ SoarKernel/src/init_soar.cpp	(working copy)
@@ -42,8 +42,8 @@
 #include "wma.h"
 #include "episodic_memory.h"
 #include "semantic_memory.h"
+#include "svs.h"
 
-
 #define INIT_FILE       "init.soar"
 
 /* REW: begin 08.20.97   these defined in consistency.c  */
@@ -601,6 +601,8 @@
 		  BEFORE_INPUT_PHASE_CALLBACK,
 		  reinterpret_cast<soar_call_data>(INPUT_PHASE));
 
+	  thisAgent->svs_instance->input_callback();
+
       do_input_cycle(thisAgent);
 
 	  thisAgent->run_phase_count++ ;
@@ -919,6 +921,8 @@
 			 BEFORE_OUTPUT_PHASE_CALLBACK,
 			 reinterpret_cast<soar_call_data>(OUTPUT_PHASE) );
  
+	  thisAgent->svs_instance->output_callback();
+
 	  /** KJC June 05:  moved output function timers into do_output_cycle ***/
 
 	  do_output_cycle(thisAgent);
Index: SoarKernel/src/agent.h
===================================================================
--- SoarKernel/src/agent.h	(revision 13180)
+++ SoarKernel/src/agent.h	(working copy)
@@ -135,6 +135,7 @@
 typedef char * test;
 
 class stats_statement_container;
+class svs;
 
 typedef struct agent_struct {
   /* After v8.6.1, all conditional compilations were removed
@@ -944,6 +945,7 @@
   // Soar execution will be interrupted when this substate level is removed
   goal_stack_level substate_break_level;
 
+  svs *svs_instance;
 } agent;
 /*************** end of agent struct *****/
 
Index: SoarKernel/src/decide.cpp
===================================================================
--- SoarKernel/src/decide.cpp	(revision 13180)
+++ SoarKernel/src/decide.cpp	(working copy)
@@ -61,6 +61,7 @@
 
 #include "episodic_memory.h"
 #include "semantic_memory.h"
+#include "svs.h"
 
 #include "assert.h"
 
@@ -2262,7 +2263,8 @@
   symbol_remove_ref( thisAgent, goal->id.smem_header );
   free_with_pool( &( thisAgent->smem_info_pool ), goal->id.smem_info );
 
-
+  thisAgent->svs_instance->state_deletion_callback(goal);
+  
   /* REW: BUG
    * Tentative assertions can exist for removed goals.  However, it looks
    * like the removal forces a tentative retraction, which then leads to
@@ -2391,6 +2393,8 @@
   soar_invoke_callbacks(thisAgent, 
                        CREATE_NEW_CONTEXT_CALLBACK, 
                        static_cast<soar_call_data>(id) );
+  
+  thisAgent->svs_instance->state_creation_callback(id);
 }
 
 /* ------------------------------------------------------------------
Index: xcopy-exclude.txt
===================================================================
--- xcopy-exclude.txt	(revision 13180)
+++ xcopy-exclude.txt	(working copy)
@@ -1,2 +0,0 @@
-.svn
-
Index: ConnectionSML/src/sml_Names.cpp
===================================================================
--- ConnectionSML/src/sml_Names.cpp	(revision 13180)
+++ ConnectionSML/src/sml_Names.cpp	(working copy)
@@ -451,3 +451,6 @@
 
 // command line interface
 char const* const sml_Names::kCommand_CommandLine		 = "cmdline" ;
+
+char const* const sml_Names::kCommand_SVSInput   = "svs_input";
+char const* const sml_Names::kCommand_SVSOutput  = "svs_output";
Index: ConnectionSML/src/sml_Names.h
===================================================================
--- ConnectionSML/src/sml_Names.h	(revision 13180)
+++ ConnectionSML/src/sml_Names.h	(working copy)
@@ -441,6 +441,9 @@
 
 	// Command line interface
 	static char const* const kCommand_CommandLine ;
+	
+	static char const* const kCommand_SVSInput ;
+	static char const* const kCommand_SVSOutput ;
 } ;
 
 }
