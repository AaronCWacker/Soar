#!/bin/sh

# This is the static front part of the file
cat  >src/filter_factory.cpp <<EOF
/* Auto-generated by gen_filter_factory */
#include <vector>
#include <string>
#include <map>
#include "filter.h"

using namespace std;

struct table_entry {
	std::string name;
	std::vector<std::string> &parameters;
	filter* (*construct)(scene*, filter_input*);
	bool    (*calc)(scene*, const vector<string> &);
	void    (*possible_args)(scene *, vector<vector<string> > &);
};

EOF

# This awk script will parse the cpp files in the filters/ directory
# and output all the necessary function signatures for filter construction
# and standalone calculation. It also outputs the lookup table for
# everything.
awk '
BEGIN {
	while (("ls src/filters/*.cpp" | getline file) > 0) {
		while ((getline < file) == 1) {
			if (match($0, "_make_[a-zA-Z0-9_]+_filter_" ) > 0) {
				name = substr($0, RSTART + 6, RLENGTH - 14);
				all_funcs[name] = 1
				filters[name] = 1
			}
			
			if (match($0, "_standalone_[a-zA-Z0-9_]+" ) > 0) {
				name = substr($0, RSTART + 12, RLENGTH - 12);
				all_funcs[name] = 1
				standalones[name] = 1
			}
			
			if (match($0, "_possible_params_[a-zA-Z0-9_]+" ) > 0) {
				name = substr($0, RSTART + 17, RLENGTH - 17);
				all_funcs[name] = 1
				params[name] = 1
			}
		}
	}
	
	for (n in filters) {
		printf ("filter* _make_%s_filter_(scene *scn, filter_input *input);\n", n)
	}
	
	for (n in standalones) {
		printf ("bool _standalone_%s(scene *scn, const map<string, string> &params);\n", n)
	}
	
	for (n in params) {
		printf ("void _possible_params_%s(scene *scn, vector<map<string, string> > &params);\n", n);
	}
	
	print "\nstatic table_entry filter_table[] = {"
	for (n in all_funcs) {
		if (filters[n] == 1) {
			f = sprintf("_make_%s_filter_", n);
		} else {
			f = "NULL";
		}
		
		if (standalones[n] == 1) {
			s = sprintf("_standalone_%s", n);
		} else {
			s = "NULL";
		}
		
		if (params[n] == 1) {
			p = sprintf("_possible_params_%s", n);
		} else {
			p = "NULL";
		}
		
		printf ("	{ \"%s\", %s, %s, %s },\n", n, f, s, p);
	}
	
	print "};"
}
' >>src/filter_factory.cpp


# Static tail part of the file
cat >>src/filter_factory.cpp <<EOFEOF

table_entry *find_entry(const string &name) {
	int tabsize = sizeof(filter_table) / sizeof(table_entry);
	for(int i = 0; i < tabsize; ++i) {
		if (name == filter_table[i].name) {
			return filter_table + i;
		}
	}
	return NULL;
}

filter* make_filter(const string &name, scene *scn, filter_input *input) {
	table_entry *entry = find_entry(name);
	if (entry == NULL || entry->construct == NULL) {
		return NULL;
	}
	return (entry->construct)(scn, input);
}

void get_predicate_table(scene *scn, vector<pair<string, map<string, string> > > &ptable) {
	int tabsize = sizeof(filter_table) / sizeof(table_entry);
	for(int i = 0; i < tabsize; ++i) {
		if (filter_table[i].possible_params != NULL) {
			vector<map<string, string> > poss_params;
			vector<map<string, string> >::iterator j;
			(*filter_table[i].possible_params)(scn, poss_params);
			for (j = poss_params.begin(); j != poss_params.end(); ++j) {
				ptable.push_back(make_pair(filter_table[i].name, *j));
			}
		}
	}
}

void calc_all_predicates(scene *scn, vector<bool> &results) {
	int tabsize = sizeof(filter_table) / sizeof(table_entry);
	results.clear();
	for(int i = 0; i < tabsize; ++i) {
		table_entry &entry = filter_table[i];
		string &predname = entry.name;
		if (entry.possible_params != NULL) {
			vector<map<string, string> > param_sets;
			vector<map<string, string> >::const_iterator j;
			
			(*entry.possible_params)(scn, all_params);
			for(j = param_sets.begin(); j != param_sets.end(); ++j) {
				results.push_back((*entry.calc)(scn, *j));
			}
		}
	}
}

EOFEOF
